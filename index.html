<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Physics Sandbox</title>
<style>
  html, body { margin:0; height:100%; background:#0b0b0b; touch-action:none; }
  canvas { display:block; width:100vw; height:100vh; }
</style>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });

// Material constants
const EMPTY=0, SAND=1, WATER=2, SOIL=3, GRASS=4, BOMB=5;
const cellSize = 4;  // grid cell size in pixels

let width=0, height=0;
let simCols=0, simRows=0;
let grid=[], isStatic=[];
let bombs=[];
let soilExposeTime={}, grassCoverTime={};

function resize() {
  const ratio = window.devicePixelRatio || 1;
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width * ratio;
  canvas.height = height * ratio;
  ctx.setTransform(ratio,0,0,ratio,0,0);
  simCols = Math.floor(width / cellSize);
  simRows = Math.floor(height / cellSize);
  grid = Array.from({length: simRows}, () => Array(simCols).fill(EMPTY));
  isStatic = Array.from({length: simRows}, () => Array(simCols).fill(false));
}
addEventListener('resize', resize, { passive:true });
resize();

let frame = 0;
function updateParticles() {
  frame++;
  const biasLeftFirst = (frame % 2 === 0);
  for (let y = simRows - 2; y >= 0; y--) {
    const xStart = (frame % 2 === 0 ? 0 : simCols - 1);
    const xEnd   = (frame % 2 === 0 ? simCols : -1);
    const xStep  = (frame % 2 === 0 ? 1 : -1);
    for (let x = xStart; x !== xEnd; x += xStep) {
      const type = grid[y][x];
      if (type===EMPTY || type===GRASS) continue;
      if (isStatic[y][x]) continue;
      const belowY = y + 1;
      const leftX = x - 1, rightX = x + 1;
      const inBoundsX = nx => (nx >= 0 && nx < simCols);
      const cell = (r,c) => grid[r]?.[c];
      let moved = false;
      if (cell(belowY, x) === EMPTY) {
        grid[belowY][x] = type;
        grid[y][x] = EMPTY;
        isStatic[belowY][x] = false;
        isStatic[y][x] = false;
        if (y - 1 >= 0 && isStatic[y-1][x]) isStatic[y-1][x] = false;
        moved = true;
      } else if (biasLeftFirst) {
        if (inBoundsX(leftX) && cell(belowY, leftX) === EMPTY) {
          grid[belowY][leftX] = type;
          grid[y][x] = EMPTY;
          isStatic[belowY][leftX] = false;
          isStatic[y][x] = false;
          if (y - 1 >= 0 && isStatic[y-1][x]) isStatic[y-1][x] = false;
          moved = true;
        } else if (inBoundsX(rightX) && cell(belowY, rightX) === EMPTY) {
          grid[belowY][rightX] = type;
          grid[y][x] = EMPTY;
          isStatic[belowY][rightX] = false;
          isStatic[y][x] = false;
          if (y - 1 >= 0 && isStatic[y-1][x]) isStatic[y-1][x] = false;
          moved = true;
        }
      } else {
        if (inBoundsX(rightX) && cell(belowY, rightX) === EMPTY) {
          grid[belowY][rightX] = type;
          grid[y][x] = EMPTY;
          isStatic[belowY][rightX] = false;
          isStatic[y][x] = false;
          if (y - 1 >= 0 && isStatic[y-1][x]) isStatic[y-1][x] = false;
          moved = true;
        } else if (inBoundsX(leftX) && cell(belowY, leftX) === EMPTY) {
          grid[belowY][leftX] = type;
          grid[y][x] = EMPTY;
          isStatic[belowY][leftX] = false;
          isStatic[y][x] = false;
          if (y - 1 >= 0 && isStatic[y-1][x]) isStatic[y-1][x] = false;
          moved = true;
        }
      }
      if (!moved && type === WATER) {
        if (cell(belowY, x) !== EMPTY) {
          const dir = Math.random() < 0.5 ? -1 : 1;
          for (let attempt = 0; attempt < 2; attempt++) {
            const nx = (attempt === 0 ? x + dir : x - dir);
            if (inBoundsX(nx) && cell(y, nx) === EMPTY && cell(belowY, nx) !== EMPTY) {
              grid[y][nx] = WATER;
              grid[y][x] = EMPTY;
              isStatic[y][nx] = false;
              isStatic[y][x] = false;
              moved = true;
              break;
            }
          }
        }
      }
      if (!moved && cell(belowY, x) !== undefined) {
        const belowType = cell(belowY, x);
        const density = { [WATER]:1, [SAND]:2, [SOIL]:2, [BOMB]:3 };
        if (belowType !== EMPTY && density[type] > density[belowType]) {
          grid[belowY][x] = type;
          grid[y][x] = belowType;
          isStatic[belowY][x] = false;
          isStatic[y][x] = false;
          moved = true;
        }
      }
      if (!moved) {
        isStatic[y][x] = true;
      }
    }
  }
}

const BLAST_RADIUS = 5;
const BLAST_INNER = 2;
function updateBombs(dt) {
  for (let i = bombs.length - 1; i >= 0; i--) {
    bombs[i].fuse -= dt;
    if (bombs[i].fuse <= 0) {
      const bx = bombs[i].x, by = bombs[i].y;
      grid[by][bx] = EMPTY;
      isStatic[by][bx] = false;
      for (let yy = Math.max(0, by - BLAST_RADIUS); yy <= Math.min(simRows-1, by + BLAST_RADIUS); yy++) {
        for (let xx = Math.max(0, bx - BLAST_RADIUS); xx <= Math.min(simCols-1, bx + BLAST_RADIUS); xx++) {
          const dx = xx - bx, dy = yy - by;
          const distSq = dx*dx + dy*dy;
          if (distSq <= BLAST_RADIUS * BLAST_RADIUS) {
            const dist = Math.sqrt(distSq);
            if (dist <= BLAST_INNER) {
              if (grid[yy][xx] !== EMPTY) {
                grid[yy][xx] = EMPTY;
                isStatic[yy][xx] = false;
                delete soilExposeTime[`${xx},${yy}`];
                delete grassCoverTime[`${xx},${yy}`];
              }
            } else {
              if (grid[yy][xx] !== EMPTY && grid[yy][xx] !== BOMB) {
                const pushX = dx / dist, pushY = dy / dist;
                const force = 1 / distSq;
                const throwDist = Math.min(Math.ceil(force * BLAST_RADIUS * 2), BLAST_RADIUS);
                let newX = xx + Math.round(pushX * throwDist);
                let newY = yy + Math.round(pushY * throwDist);
                newX = Math.max(0, Math.min(simCols-1, newX));
                newY = Math.max(0, Math.min(simRows-1, newY));
                if (!(newX === xx && newY === yy)) {
                  if (grid[newY][newX] !== EMPTY) {
                    let placed = false;
                    for (let oy = -1; oy <= 1 && !placed; oy++) {
                      for (let ox = -1; ox <= 1 && !placed; ox++) {
                        const tx = xx + ox, ty = yy + oy;
                        if (tx>=0 && tx<simCols && ty>=0 && ty<simRows && grid[ty][tx]===EMPTY) {
                          newX = tx; newY = ty; placed = true;
                        }
                      }
                    }
                    if (!placed) continue;
                  }
                  grid[newY][newX] = grid[yy][xx];
                  grid[yy][xx] = EMPTY;
                  isStatic[newY][newX] = false;
                  isStatic[yy][xx] = false;
                }
              }
            }
          }
        }
      }
      bombs.splice(i, 1);
    }
  }
}

function updateSoilAndGrass(dt) {
  for (let y = 0; y < simRows; y++) {
    for (let x = 0; x < simCols; x++) {
      if (grid[y][x] === SOIL) {
        if (y === 0 || grid[y-1][x] === EMPTY) {
          const key = `${x},${y}`;
          soilExposeTime[key] = (soilExposeTime[key] || 0) + dt;
          if (soilExposeTime[key] >= 180) {
            grid[y][x] = GRASS;
            grassCoverTime[key] = 0;
            soilExposeTime[key] = 0;
          }
        } else {
          soilExposeTime[`${x},${y}`] = 0;
        }
      }
      else if (grid[y][x] === GRASS) {
        const key = `${x},${y}`;
        if (y !== 0 && grid[y-1][x] !== EMPTY) {
          grassCoverTime[key] = (grassCoverTime[key] || 0) + dt;
          if (grassCoverTime[key] >= 30) {
            grid[y][x] = SOIL;
            soilExposeTime[key] = 0;
            grassCoverTime[key] = 0;
          }
        } else {
          grassCoverTime[key] = 0;
        }
      }
    }
  }
}

function draw() {
  ctx.fillStyle = '#101014';
  ctx.fillRect(0, 0, width, height);
  for (let y = 0; y < simRows; y++) {
    for (let x = 0; x < simCols; x++) {
      switch(grid[y][x]) {
        case SAND: ctx.fillStyle = '#fc0'; break;
        case WATER: ctx.fillStyle = '#39f'; break;
        case SOIL: ctx.fillStyle = '#764c24'; break;
        case GRASS: ctx.fillStyle = '#3c9d30'; break;
        case BOMB: ctx.fillStyle = '#f00'; break;
        default: continue;
      }
      ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
    }
  }
}

let last = performance.now();
function loop(now) {
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;
  updateParticles();
  updateBombs(dt);
  updateSoilAndGrass(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Input handling
let currentMaterial = WATER;
window.addEventListener('keydown', e => {
  if (e.key === '1') currentMaterial = WATER;
  if (e.key === '2') currentMaterial = SAND;
  if (e.key === '3') currentMaterial = SOIL;
  if (e.key === '4') currentMaterial = BOMB;
});

let spawnInterval;
canvas.addEventListener('pointerdown', e => {
  const rect = canvas.getBoundingClientRect();
  const gridX = Math.floor((e.clientX - rect.left) / cellSize);
  const gridY = Math.floor((e.clientY - rect.top) / cellSize);
  function spawnParticle() {
    if (gridY < 0 || gridY >= simRows || gridX < 0 || gridX >= simCols) return;
    if (currentMaterial === SOIL) {
      const r = 2;
      for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
          if (dx*dx + dy*dy <= r*r) {
            const x = gridX + dx, y = gridY + dy;
            if (y >= 0 && y < simRows && x >= 0 && x < simCols && grid[y][x] === EMPTY) {
              grid[y][x] = SOIL;
              isStatic[y][x] = false;
              soilExposeTime[`${x},${y}`] = 0;
            }
          }
        }
      }
    } else {
      if (grid[gridY][gridX] === EMPTY) {
        grid[gridY][gridX] = currentMaterial;
        isStatic[gridY][gridX] = false;
        if (currentMaterial === BOMB) {
          bombs.push({x: gridX, y: gridY, fuse: 3});
        }
      }
    }
  }
  spawnParticle();
  clearInterval(spawnInterval);
  spawnInterval = setInterval(spawnParticle, 50);
});
['pointerup','pointercancel','pointerout'].forEach(ev => canvas.addEventListener(ev, () => clearInterval(spawnInterval)));
</script>
</html>
