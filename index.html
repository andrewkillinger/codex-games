<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Serene Soil</title>
<style>
  html, body { margin:0; height:100%; background:#000; touch-action:none; }
  canvas { position:absolute; left:0; top:0; image-rendering:pixelated; }
</style>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });

// material constants
const EMPTY=0, SOIL=1, GRASS=2;
const cellSize = 4;

let width=0, height=0;
let simCols=0, simRows=0;
let grid=[], isStatic=[];
let soilExposeTime={};

let frame=0;
let dayTime=0;
let stars=[], clouds=[];

function lerp(a,b,t){ return a+(b-a)*t; }
function mixColor(c1,c2,t){
  const r1=parseInt(c1.slice(1,3),16), g1=parseInt(c1.slice(3,5),16), b1=parseInt(c1.slice(5,7),16);
  const r2=parseInt(c2.slice(1,3),16), g2=parseInt(c2.slice(3,5),16), b2=parseInt(c2.slice(5,7),16);
  const r=Math.round(lerp(r1,r2,t)), g=Math.round(lerp(g1,g2,t)), b=Math.round(lerp(b1,b2,t));
  return `rgb(${r},${g},${b})`;
}

function initSky(){
  stars = Array.from({length:100}, () => ({
    x: Math.random()*width,
    y: Math.random()*height*0.5,
    size: Math.random()*2+1,
    alpha: Math.random()*0.5+0.5
  }));
  clouds = Array.from({length:5}, () => ({
    x: Math.random()*width,
    y: Math.random()*height*0.3,
    speed: 10+Math.random()*20
  }));
}

function createTerrain(){
  const base = Math.floor(simRows*0.75);
  let h = base;
  for (let x=0; x<simCols; x++){
    h += Math.floor(Math.random()*3)-1;
    h = Math.max(Math.floor(simRows*0.5), Math.min(simRows-1, h));
    for (let y=h; y<simRows; y++){
      grid[y][x] = SOIL;
      isStatic[y][x] = true;
    }
    grid[h][x] = GRASS;
  }
}

function resize(){
  const ratio = window.devicePixelRatio || 1;
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.style.width = width+'px';
  canvas.style.height = height+'px';
  canvas.width = width*ratio;
  canvas.height = height*ratio;
  ctx.setTransform(ratio,0,0,ratio,0,0);
  simCols = Math.floor(width/cellSize);
  simRows = Math.floor(height/cellSize);
  grid = Array.from({length:simRows}, () => Array(simCols).fill(EMPTY));
  isStatic = Array.from({length:simRows}, () => Array(simCols).fill(false));
  soilExposeTime = {};
  initSky();
  createTerrain();
}
addEventListener('resize', resize, {passive:true});
resize();

function updateParticles(){
  frame++;
  for (let y=simRows-2; y>=0; y--){
    const xStart = frame%2===0 ? 0 : simCols-1;
    const xEnd = frame%2===0 ? simCols : -1;
    const xStep = frame%2===0 ? 1 : -1;
    for (let x=xStart; x!==xEnd; x+=xStep){
      if (grid[y][x] !== SOIL || isStatic[y][x]) continue;
      const belowY = y+1;
      if (grid[belowY][x] === EMPTY){
        grid[belowY][x] = SOIL;
        grid[y][x] = EMPTY;
        isStatic[belowY][x] = false;
        isStatic[y][x] = false;
        if (y>0) isStatic[y-1][x] = false;
      } else {
        const dirs = frame%2===0 ? [-1,1] : [1,-1];
        let moved = false;
        for (const dx of dirs){
          const nx = x+dx;
          if (nx>=0 && nx<simCols && grid[belowY][nx] === EMPTY){
            grid[belowY][nx] = SOIL;
            grid[y][x] = EMPTY;
            isStatic[belowY][nx] = false;
            isStatic[y][x] = false;
            if (y>0) isStatic[y-1][x] = false;
            moved = true;
            break;
          }
        }
        if (!moved) isStatic[y][x] = true;
      }
    }
  }
}

function updateSoilAndGrass(dt){
  for (let y=0; y<simRows; y++){
    for (let x=0; x<simCols; x++){
      if (grid[y][x] === SOIL){
        if (y===0 || grid[y-1][x] === EMPTY){
          const key = `${x},${y}`;
          soilExposeTime[key] = (soilExposeTime[key] || 0) + dt;
          if (soilExposeTime[key] >= 180){
            grid[y][x] = GRASS;
            soilExposeTime[key] = 0;
          }
        } else {
          soilExposeTime[`${x},${y}`] = 0;
        }
      } else if (grid[y][x] === GRASS){
        if (y!==0 && grid[y-1][x] !== EMPTY){
          grid[y][x] = SOIL;
          soilExposeTime[`${x},${y}`] = 0;
        }
      }
    }
  }
}

function drawBackground(dt){
  dayTime = (dayTime + dt) % 300;
  const progress = dayTime / 300;
  const sunHeight = Math.sin(progress * 2*Math.PI);
  const daylight = Math.max(0, sunHeight);
  const nightLight = 1 - daylight;

  const grad = ctx.createLinearGradient(0,0,0,height);
  grad.addColorStop(0, mixColor('#001030', '#5cc0ff', daylight));
  grad.addColorStop(1, mixColor('#002', '#aeefff', daylight));
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,width,height);

  // stars
  ctx.fillStyle = '#fff';
  for (const s of stars){
    ctx.globalAlpha = nightLight * s.alpha;
    ctx.fillRect(s.x, s.y, s.size, s.size);
  }
  ctx.globalAlpha = 1;

  // clouds
  if (daylight > 0){
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.shadowColor = 'rgba(255,255,255,0.8)';
    ctx.shadowBlur = 8;
    for (const c of clouds){
      c.x += c.speed * dt;
      if (c.x > width + 60) c.x = -60;
      ctx.beginPath();
      ctx.ellipse(c.x, c.y, 40, 20, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.shadowBlur = 0;
  }

  // sun or moon
  const sunX = progress * width;
  const baseY = height * 0.7;
  const sunY = baseY - sunHeight * height * 0.5;
  if (daylight > 0){
    ctx.fillStyle = '#ffd35c';
    ctx.shadowColor = '#ffd35c';
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(sunX, sunY, 20, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
  } else {
    ctx.fillStyle = '#ccddee';
    ctx.shadowColor = '#ccddee';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(sunX, baseY - (-sunHeight) * height * 0.5, 15, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawTerrain(){
  for (let y=0; y<simRows; y++){
    for (let x=0; x<simCols; x++){
      if (grid[y][x] === SOIL){
        ctx.fillStyle = '#4e2b14';
        ctx.shadowColor = '#4e2b14';
        ctx.shadowBlur = 4;
        ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
        ctx.shadowBlur = 0;
      } else if (grid[y][x] === GRASS){
        const gx=x*cellSize, gy=y*cellSize;
        ctx.fillStyle = '#4e2b14';
        ctx.fillRect(gx, gy, cellSize, cellSize);
        ctx.fillStyle = '#2dd82d';
        ctx.shadowColor = '#2dd82d';
        ctx.shadowBlur = 6;
        ctx.fillRect(gx, gy, cellSize, 2);
        ctx.fillStyle = '#3cff3c';
        ctx.fillRect(gx, gy, cellSize, 1);
        ctx.shadowBlur = 0;
      }
    }
  }
}

function draw(dt){
  drawBackground(dt);
  drawTerrain();
}

let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  updateParticles();
  updateSoilAndGrass(dt);
  draw(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// interaction
let pointerDown=false;
let pointerButton=0;
let pointerX=0, pointerY=0;

function updatePointer(e){
  const rect = canvas.getBoundingClientRect();
  pointerX = Math.floor((e.clientX - rect.left)/cellSize);
  pointerY = Math.floor((e.clientY - rect.top)/cellSize);
}

function modifyAtPointer(btn){
  const gridX = pointerX, gridY = pointerY;
  if (gridY<0 || gridY>=simRows || gridX<0 || gridX>=simCols) return;
  if (btn===0){
    const r=2;
    for (let dy=-r; dy<=r; dy++){
      for (let dx=-r; dx<=r; dx++){
        if (dx*dx+dy*dy <= r*r){
          const x = gridX+dx, y = gridY+dy;
          if (y>=0 && y<simRows && x>=0 && x<simCols && grid[y][x]===EMPTY){
            grid[y][x] = SOIL;
            isStatic[y][x] = false;
            soilExposeTime[`${x},${y}`] = 0;
          }
        }
      }
    }
  } else if (btn===2){
    if (grid[gridY][gridX] !== EMPTY){
      grid[gridY][gridX] = EMPTY;
      isStatic[gridY][gridX] = false;
      delete soilExposeTime[`${gridX},${gridY}`];
    }
  }
}

let spawnInterval;
canvas.addEventListener('pointerdown', e => {
  pointerDown = true;
  pointerButton = e.button;
  updatePointer(e);
  modifyAtPointer(pointerButton);
  clearInterval(spawnInterval);
  spawnInterval = setInterval(()=>modifyAtPointer(pointerButton), 50);
});
canvas.addEventListener('pointermove', e => { if (pointerDown) updatePointer(e); });
['pointerup','pointercancel','pointerout'].forEach(ev => canvas.addEventListener(ev, () => {
  pointerDown = false;
  clearInterval(spawnInterval);
}));
canvas.addEventListener('contextmenu', e => e.preventDefault());
</script>
</html>

