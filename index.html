<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Serene Soil</title>
<style>
  html, body { margin:0; height:100%; background:#000; touch-action:none; }
  canvas { position:absolute; left:0; top:0; image-rendering:pixelated; }
  #toolbar { position:absolute; top:10px; left:50%; transform:translateX(-50%); z-index:10; }
</style>
<canvas id="game"></canvas>
<div id="toolbar"><button id="modeBtn">Mode: Place</button> <button id="matBtn">Material: Soil</button></div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });

// material constants
const EMPTY=0, SOIL=1, GRASS=2, WATER=3;
const cellSize = 4;

let width=0, height=0;
let simCols=0, simRows=0;
let grid=[], isStatic=[];
let soilExposeTime={};

let mode='place';

let currentMaterial = SOIL;

let frame=0;
const modeBtn = document.getElementById("modeBtn");
modeBtn.addEventListener("click", () => {
  mode = mode==="place" ? "interact" : "place";
  modeBtn.textContent = "Mode: " + (mode==="place" ? "Place" : "Interact");
});
const matBtn = document.getElementById("matBtn");
matBtn.addEventListener("click", () => {
  currentMaterial = currentMaterial===SOIL ? WATER : SOIL;
  matBtn.textContent = "Material: " + (currentMaterial===SOIL ? "Soil" : "Water");
});
let dayTime=0;
let stars=[], clouds=[];
let currentDaylight=1, currentSunX=0;

function lerp(a,b,t){ return a+(b-a)*t; }
function mixColor(c1,c2,t){
  const r1=parseInt(c1.slice(1,3),16), g1=parseInt(c1.slice(3,5),16), b1=parseInt(c1.slice(5,7),16);
  const r2=parseInt(c2.slice(1,3),16), g2=parseInt(c2.slice(3,5),16), b2=parseInt(c2.slice(5,7),16);
  const r=Math.round(lerp(r1,r2,t)), g=Math.round(lerp(g1,g2,t)), b=Math.round(lerp(b1,b2,t));
  return `rgb(${r},${g},${b})`;
}

function initSky(){
  stars = Array.from({length:100}, () => ({
    x: Math.random()*width,
    y: Math.random()*height*0.5,
    size: Math.random()*2+1,
    alpha: Math.random()*0.5+0.5
  }));
  clouds = Array.from({length:5}, () => ({
    x: Math.random()*width,
    y: Math.random()*height*0.3,
    speed: 10+Math.random()*20,
    puffs: Array.from({length:3+Math.floor(Math.random()*3)}, () => ({
      ox: Math.random()*60-30,
      oy: Math.random()*20-10,
      w: 20+Math.random()*20,
      h: 10+Math.random()*10
    }))
  }));
}

function createTerrain(){
  const base = Math.floor(simRows*0.75);
  let h = base;
  for (let x=0; x<simCols; x++){
    h += Math.floor(Math.random()*3)-1;
    h = Math.max(Math.floor(simRows*0.5), Math.min(simRows-1, h));
    for (let y=h; y<simRows; y++){
      grid[y][x] = SOIL;
      isStatic[y][x] = true;
    }
    grid[h][x] = GRASS;
  }
}

function resize(){
  const ratio = window.devicePixelRatio || 1;
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.style.width = width+'px';
  canvas.style.height = height+'px';
  canvas.width = width*ratio;
  canvas.height = height*ratio;
  ctx.setTransform(ratio,0,0,ratio,0,0);
  simCols = Math.floor(width/cellSize);
  simRows = Math.floor(height/cellSize);
  grid = Array.from({length:simRows}, () => Array(simCols).fill(EMPTY));
  isStatic = Array.from({length:simRows}, () => Array(simCols).fill(false));
  soilExposeTime = {};
  initSky();
  createTerrain();
}
addEventListener('resize', resize, {passive:true});
resize();

function updateParticles(){
  frame++;
  for (let y=simRows-2; y>=0; y--){
    const xStart = frame%2===0 ? 0 : simCols-1;
    const xEnd = frame%2===0 ? simCols : -1;
    const xStep = frame%2===0 ? 1 : -1;
    for (let x=xStart; x!==xEnd; x+=xStep){
      const cell = grid[y][x];
      if (cell === SOIL){
        if (isStatic[y][x]) continue;
        const belowY = y+1;
        const belowCell = grid[belowY][x];
        if (belowCell === EMPTY || belowCell === WATER){
          grid[belowY][x] = SOIL;
          grid[y][x] = belowCell === WATER ? WATER : EMPTY;
          isStatic[belowY][x] = false;
          isStatic[y][x] = false;
          if (y>0) isStatic[y-1][x] = false;
        } else {
          const dirs = frame%2===0 ? [-1,1] : [1,-1];
          let moved = false;
          for (const dx of dirs){
            const nx = x+dx;
            if (nx>=0 && nx<simCols){
              const diag = grid[belowY][nx];
              if (diag === EMPTY || diag === WATER){
                grid[belowY][nx] = SOIL;
                grid[y][x] = diag === WATER ? WATER : EMPTY;
                isStatic[belowY][nx] = false;
                isStatic[y][x] = false;
                if (y>0) isStatic[y-1][x] = false;
                moved = true;
                break;
              }
            }
          }
          if (!moved) isStatic[y][x] = true;
        }
      } else if (cell === WATER){
        const belowY = y+1;
        const belowCell = belowY<simRows ? grid[belowY][x] : SOIL;
        if (belowY<simRows && (belowCell === EMPTY || belowCell === SOIL)){
          if (belowCell === SOIL){
            grid[y][x] = SOIL;
          } else {
            grid[y][x] = EMPTY;
          }
          grid[belowY][x] = WATER;
        } else {
          const dirs = frame%2===0 ? [-1,1] : [1,-1];
          let moved = false;
          for (const dir of dirs){
            let nx = x + dir;
            while (nx>=0 && nx<simCols && grid[y][nx] === WATER) nx += dir;
            if (nx<0 || nx>=simCols) continue;
            const target = grid[y][nx];
            const belowTarget = belowY<simRows ? grid[belowY][nx] : SOIL;
            if (target === EMPTY){
              if (belowY<simRows && belowTarget === EMPTY){
                grid[belowY][nx] = WATER;
              } else {
                grid[y][nx] = WATER;
              }
              grid[y][x] = EMPTY;
              moved = true;
              break;
            } else if (belowY<simRows && belowTarget === EMPTY){
              grid[belowY][nx] = WATER;
              grid[y][x] = EMPTY;
              moved = true;
              break;
            }
          }
          if (!moved){
            for (const dx of dirs){
              const nx = x+dx;
              if (nx>=0 && nx<simCols && grid[y][nx] === EMPTY){
                grid[y][nx] = WATER;
                grid[y][x] = EMPTY;
                break;
              }
            }
          }
        }
      }
    }
  }
}

function updateSoilAndGrass(dt){
  for (let y=0; y<simRows; y++){
    for (let x=0; x<simCols; x++){
      if (grid[y][x] === SOIL){
        if (y===0 || grid[y-1][x] === EMPTY){
          const key = `${x},${y}`;
          soilExposeTime[key] = (soilExposeTime[key] || 0) + dt;
          if (soilExposeTime[key] >= 90){
            grid[y][x] = GRASS;
            soilExposeTime[key] = 0;
          }
        } else {
          soilExposeTime[`${x},${y}`] = 0;
        }
      } else if (grid[y][x] === GRASS){
        if (y!==0 && grid[y-1][x] !== EMPTY){
          grid[y][x] = SOIL;
          soilExposeTime[`${x},${y}`] = 0;
        }
      }
    }
  }
}

function drawBackground(dt){
  dayTime = (dayTime + dt) % 300;
  const progress = dayTime / 300;
  const angle = progress * 2*Math.PI;
  const sunHeight = Math.sin(angle);
  const daylight = Math.max(0, sunHeight);
  currentDaylight = daylight;
  const nightLight = 1 - daylight;

  const dayTop = '#78a7ff';
  const dayBottom = '#b5dbff';
  const nightTop = '#0b0d17';
  const nightBottom = '#000000';
  const skyTop = mixColor(nightTop, dayTop, daylight);
  const skyBottom = mixColor(nightBottom, dayBottom, daylight);
  const grad = ctx.createLinearGradient(0,0,0,height);
  grad.addColorStop(0, skyTop);
  grad.addColorStop(1, skyBottom);
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,width,height);

  // stars
  ctx.fillStyle = '#fff';
  for (const s of stars){
    ctx.globalAlpha = nightLight * s.alpha;
    ctx.fillRect(s.x, s.y, s.size, s.size);
  }
  ctx.globalAlpha = 1;

  // clouds
  if (daylight > 0){
    ctx.fillStyle = '#ffffff';
    for (const c of clouds){
      c.x += c.speed * dt;
      if (c.x > width + 80) c.x = -80;
      for (const p of c.puffs){
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(c.x + p.ox, c.y + p.oy, p.w, p.h);
        ctx.fillStyle = '#c0c0c0';
        ctx.fillRect(c.x + p.ox, c.y + p.oy + p.h - 4, p.w, 4);
      }
    }
  }

  // sun or moon
  const sunX = progress * width;
  currentSunX = sunX;
  const baseY = height * 0.7;
  const sunY = baseY - sunHeight * height * 0.5;
  if (daylight > 0){
    ctx.fillStyle = '#ffd35c';
    ctx.fillRect(sunX-20, sunY-20, 40, 40);
  } else {
    const moonY = baseY - (-sunHeight) * height * 0.5;
    ctx.fillStyle = '#ccddee';
    ctx.fillRect(sunX-15, moonY-15, 30, 30);
  }
}

function drawTerrain(){
  for (let y=0; y<simRows; y++){
    for (let x=0; x<simCols; x++){
      if (grid[y][x] === SOIL){
        const depth = y/simRows;
        const topLight = 0.3 + 0.7*currentDaylight;
        const shade = Math.max(0, topLight - depth*0.8);
        ctx.fillStyle = mixColor('#1b0e06','#4e2b14', shade);
        ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
      } else if (grid[y][x] === GRASS){
        const gx=x*cellSize, gy=y*cellSize;
        ctx.fillStyle = '#4e2b14';
        ctx.fillRect(gx, gy, cellSize, cellSize);
        ctx.fillStyle = '#2dd82d';
        ctx.shadowColor = '#2dd82d';
        ctx.shadowBlur = 6;
        ctx.fillRect(gx, gy, cellSize, 2);
        ctx.fillStyle = '#3cff3c';
        ctx.fillRect(gx, gy, cellSize, 1);
        ctx.shadowBlur = 0;
      } else if (grid[y][x] === WATER){
        const gx=x*cellSize, gy=y*cellSize;
        const depth = y/simRows;
        const baseColor = mixColor('#003355','#4aa3ff',1-depth);
        ctx.fillStyle = baseColor;
        ctx.fillRect(gx, gy, cellSize, cellSize);
      }
    }
  }
}

function draw(dt){
  drawBackground(dt);
  drawTerrain();
}

let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  updateParticles();
  updateSoilAndGrass(dt);
  draw(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// interaction
let pointerDown=false;
let pointerButton=0;
let pointerX=0, pointerY=0;
let dragX=0, dragY=0;

function updatePointer(e){
  const rect = canvas.getBoundingClientRect();
  pointerX = Math.floor((e.clientX - rect.left)/cellSize);
  pointerY = Math.floor((e.clientY - rect.top)/cellSize);
}

function modifyAtPointer(btn){
  const gridX = pointerX, gridY = pointerY;
  if (gridY<0 || gridY>=simRows || gridX<0 || gridX>=simCols) return;
  if (btn===0){
    const r=2;
    for (let dy=-r; dy<=r; dy++){
      for (let dx=-r; dx<=r; dx++){
        if (dx*dx+dy*dy <= r*r){
          const x = gridX+dx, y = gridY+dy;
          if (y>=0 && y<simRows && x>=0 && x<simCols && grid[y][x]===EMPTY){
            grid[y][x] = currentMaterial;
            isStatic[y][x] = false;
            if (currentMaterial===SOIL) soilExposeTime[`${x},${y}`] = 0;
          }
        }
      }
    }
  } else if (btn===2){
    if (grid[gridY][gridX] !== EMPTY){
      grid[gridY][gridX] = EMPTY;
      isStatic[gridY][gridX] = false;
      delete soilExposeTime[`${gridX},${gridY}`];
    }
  }
}

function pushCell(x,y,dx,dy){
  if (x<0||x>=simCols||y<0||y>=simRows) return false;
  if (grid[y][x]===EMPTY) return true;
  const nx=x+dx, ny=y+dy;
  if (!pushCell(nx,ny,dx,dy)) return false;
  grid[ny][nx]=grid[y][x];
  isStatic[ny][nx]=false;
  if (grid[ny][nx]===SOIL){
    soilExposeTime[`${nx},${ny}`]=soilExposeTime[`${x},${y}`];
    delete soilExposeTime[`${x},${y}`];
  }
  grid[y][x]=EMPTY;
  isStatic[y][x]=false;
  return true;
}

function moveCell(x,y,dx,dy){
  const nx=x+dx, ny=y+dy;
  if (nx<0||nx>=simCols||ny<0||ny>=simRows) return;
  if (grid[y][x]===EMPTY) return;
  if (pushCell(nx,ny,dx,dy)){
    grid[ny][nx]=grid[y][x];
    isStatic[ny][nx]=false;
    if (grid[ny][nx]===SOIL) soilExposeTime[`${nx},${ny}`]=soilExposeTime[`${x},${y}`];
    grid[y][x]=EMPTY;
    isStatic[y][x]=false;
    delete soilExposeTime[`${x},${y}`];
  }
}

function moveRegion(cx,cy,dx,dy){
  const r=2;
  const cells=[];
  for (let dy0=-r; dy0<=r; dy0++){
    for (let dx0=-r; dx0<=r; dx0++){
      if (dx0*dx0+dy0*dy0 <= r*r){
        const x=cx+dx0, y=cy+dy0;
        if (x>=0 && x<simCols && y>=0 && y<simRows) cells.push({x,y});
      }
    }
  }
  cells.sort((a,b)=>{
    if (dy>0) return b.y - a.y;
    if (dy<0) return a.y - b.y;
    if (dx>0) return b.x - a.x;
    if (dx<0) return a.x - b.x;
    return 0;
  });
  for (const c of cells){
    moveCell(c.x, c.y, dx, dy);
  }
}

function dragMove(newX,newY){
  let dx = newX - dragX;
  let dy = newY - dragY;
  while (dx !== 0 || dy !== 0){
    const stepX = dx===0 ? 0 : dx>0 ? 1 : -1;
    const stepY = dy===0 ? 0 : dy>0 ? 1 : -1;
    moveRegion(dragX, dragY, stepX, stepY);
    dragX += stepX;
    dragY += stepY;
    dx -= stepX;
    dy -= stepY;
  }
}

let spawnInterval;
canvas.addEventListener('pointerdown', e => {
  pointerDown = true;
  pointerButton = e.button;
  updatePointer(e);
  if (mode==='place'){
    modifyAtPointer(pointerButton);
    clearInterval(spawnInterval);
    spawnInterval = setInterval(()=>modifyAtPointer(pointerButton), 50);
  } else if (mode==='interact') {
    dragX = pointerX;
    dragY = pointerY;
  }
});
canvas.addEventListener('pointermove', e => {
  updatePointer(e);
  if (pointerDown && mode==='interact'){
    dragMove(pointerX, pointerY);
  }
});
['pointerup','pointercancel','pointerout'].forEach(ev => canvas.addEventListener(ev, () => {
  pointerDown = false;
  clearInterval(spawnInterval);
}));
canvas.addEventListener('contextmenu', e => e.preventDefault());
</script>
</html>

