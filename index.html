<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Serene Soil</title>
<style>
  html, body { margin:0; height:100%; background:#000216; touch-action:none; font-family:sans-serif; }
  canvas { position:absolute; left:0; top:0; image-rendering:pixelated; }
  #toolbar { position:absolute; top:10px; left:50%; transform:translateX(-50%); z-index:10; background:rgba(0,0,0,0.5); padding:8px 12px; border-radius:8px; display:flex; gap:8px; }
  #toolbar button { background:rgba(255,255,255,0.1); color:#fff; border:none; padding:6px 12px; border-radius:4px; cursor:pointer; }
  #toolbar button:hover { background:rgba(255,255,255,0.2); }
</style>
<canvas id="game"></canvas>
<div id="toolbar"><button id="modeBtn">Mode: Place</button> <button id="matBtn">Material: Soil</button></div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });

// material constants
const EMPTY=0, SOIL=1, GRASS=2, WATER=3, TREE=4, LEAVES=5, DYNAMITE=6;
// Smaller cell size for a denser, more detailed grid
const cellSize = 4;

let width=0, height=0;
let simCols=0, simRows=0;
let grid=[], isStatic=[];
let soilExposeTime={};
let trees=[], dynamites=[];

let mode='place';

let currentMaterial = SOIL;

let frame=0;
const modeBtn = document.getElementById("modeBtn");
const matBtn = document.getElementById("matBtn");
const materials = [SOIL, WATER, TREE, DYNAMITE];
modeBtn.addEventListener("click", () => {
  mode = mode==="place" ? "interact" : "place";
  modeBtn.textContent = "Mode: " + (mode==="place" ? "Place" : "Interact");
  matBtn.style.display = mode === "place" ? "inline-block" : "none";
});
function materialLabel(mat){
  switch(mat){
    case SOIL: return "Soil";
    case WATER: return "Water";
    case TREE: return "Tree";
    case DYNAMITE: return "Dynamite";
  }
}
matBtn.addEventListener("click", () => {
  const idx = materials.indexOf(currentMaterial);
  currentMaterial = materials[(idx+1)%materials.length];
  matBtn.textContent = "Material: " + materialLabel(currentMaterial);
});
matBtn.textContent = "Material: " + materialLabel(currentMaterial);
matBtn.style.display = mode === "place" ? "inline-block" : "none";
let dayTime=0;
let stars=[], clouds=[];
let currentDaylight=1, currentSunX=0;

function lerp(a,b,t){ return a+(b-a)*t; }
function mixColor(c1,c2,t){
  const r1=parseInt(c1.slice(1,3),16), g1=parseInt(c1.slice(3,5),16), b1=parseInt(c1.slice(5,7),16);
  const r2=parseInt(c2.slice(1,3),16), g2=parseInt(c2.slice(3,5),16), b2=parseInt(c2.slice(5,7),16);
  const r=Math.round(lerp(r1,r2,t)), g=Math.round(lerp(g1,g2,t)), b=Math.round(lerp(b1,b2,t));
  return `rgb(${r},${g},${b})`;
}

function initSky(){
  stars = Array.from({length:100}, () => ({
    x: Math.random()*width,
    y: Math.random()*height*0.5,
    size: Math.random()*2+1,
    alpha: Math.random()*0.5+0.5
  }));
  clouds = Array.from({length:5}, () => ({
    x: Math.random()*width,
    y: Math.random()*height*0.3,
    speed: 10+Math.random()*20,
    puffs: Array.from({length:3+Math.floor(Math.random()*3)}, () => ({
      ox: Math.random()*60-30,
      oy: Math.random()*20-10,
      w: 20+Math.random()*20,
      h: 10+Math.random()*10
    }))
  }));
}

function createTerrain(){
  const base = Math.floor(simRows*0.75);
  let h = base;
  for (let x=0; x<simCols; x++){
    h += Math.floor(Math.random()*3)-1;
    h = Math.max(Math.floor(simRows*0.5), Math.min(simRows-1, h));
    for (let y=h; y<simRows; y++){
      grid[y][x] = SOIL;
      isStatic[y][x] = true;
    }
    grid[h][x] = GRASS;
  }
}

function resize(){
  const ratio = window.devicePixelRatio || 1;
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.style.width = width+'px';
  canvas.style.height = height+'px';
  canvas.width = width*ratio;
  canvas.height = height*ratio;
  ctx.setTransform(ratio,0,0,ratio,0,0);
  simCols = Math.floor(width/cellSize);
  simRows = Math.floor(height/cellSize);
  grid = Array.from({length:simRows}, () => Array(simCols).fill(EMPTY));
  isStatic = Array.from({length:simRows}, () => Array(simCols).fill(false));
  soilExposeTime = {};
  initSky();
  createTerrain();
}
addEventListener('resize', resize, {passive:true});
resize();

function updateParticles(){
  frame++;
  for (let y=simRows-2; y>=0; y--){
    const xStart = frame%2===0 ? 0 : simCols-1;
    const xEnd = frame%2===0 ? simCols : -1;
    const xStep = frame%2===0 ? 1 : -1;
    for (let x=xStart; x!==xEnd; x+=xStep){
      const cell = grid[y][x];
      if (cell === SOIL){
        if (isStatic[y][x]) continue;
        const belowY = y+1;
        const belowCell = grid[belowY][x];
        if (belowCell === EMPTY || belowCell === WATER){
          grid[belowY][x] = SOIL;
          grid[y][x] = belowCell === WATER ? WATER : EMPTY;
          isStatic[belowY][x] = false;
          isStatic[y][x] = false;
          if (y>0) isStatic[y-1][x] = false;
        } else {
          const dirs = frame%2===0 ? [-1,1] : [1,-1];
          let moved = false;
          for (const dx of dirs){
            const nx = x+dx;
            if (nx>=0 && nx<simCols){
              const diag = grid[belowY][nx];
              if (diag === EMPTY || diag === WATER){
                grid[belowY][nx] = SOIL;
                grid[y][x] = diag === WATER ? WATER : EMPTY;
                isStatic[belowY][nx] = false;
                isStatic[y][x] = false;
                if (y>0) isStatic[y-1][x] = false;
                moved = true;
                break;
              }
            }
          }
          if (!moved) isStatic[y][x] = true;
        }
      } else if (cell === WATER){
        // fall straight down through empty space for faster flow
        let ny = y;
        while (ny+1 < simRows && grid[ny+1][x] === EMPTY) ny++;
        if (ny !== y){
          grid[ny][x] = WATER;
          grid[y][x] = EMPTY;
          continue;
        }
        const dirs = frame%2===0 ? [-1,1] : [1,-1];
        let moved = false;
        // search sideways for lowest drop point
        for (const dir of dirs){
          let nx = x + dir;
          while (nx>=0 && nx<simCols && (grid[y][nx]===EMPTY || grid[y][nx]===WATER)){
            if (y+1 < simRows && grid[y+1][nx] === EMPTY){
              grid[y+1][nx] = WATER;
              grid[y][x] = EMPTY;
              moved = true;
              break;
            }
            nx += dir;
          }
          if (moved) break;
        }
        if (!moved){
          // otherwise slide sideways into first empty cell
          for (const dir of dirs){
            const nx = x + dir;
            if (nx>=0 && nx<simCols && grid[y][nx] === EMPTY){
              grid[y][nx] = WATER;
              grid[y][x] = EMPTY;
              break;
            }
          }
        }
      }
    }
  }
}

function updateSoilAndGrass(dt){
  for (let y=0; y<simRows; y++){
    for (let x=0; x<simCols; x++){
      if (grid[y][x] === SOIL){
        if (y===0 || grid[y-1][x] === EMPTY){
          const key = `${x},${y}`;
          soilExposeTime[key] = (soilExposeTime[key] || 0) + dt;
          if (soilExposeTime[key] >= 90){
            grid[y][x] = GRASS;
            soilExposeTime[key] = 0;
          }
        } else {
          soilExposeTime[`${x},${y}`] = 0;
        }
      } else if (grid[y][x] === GRASS){
        if (y!==0 && grid[y-1][x] !== EMPTY){
          grid[y][x] = SOIL;
          soilExposeTime[`${x},${y}`] = 0;
        }
      }
    }
  }
}

function updateTrees(dt){
  for (let i=trees.length-1; i>=0; i--){
    const t = trees[i];
    t.age += dt;
    const targetHeight = Math.min(25, Math.floor(t.age/36)+1);
    while (t.height < targetHeight){
      const ny = t.baseY - t.height;
      if (ny < 0 || grid[ny][t.x] !== EMPTY) break;
      grid[ny][t.x] = TREE;
      isStatic[ny][t.x] = true;
      t.height++;
      if (t.height > 2) addLeaves(t.x, ny);
    }
    if (grid[t.baseY][t.x] !== TREE) trees.splice(i,1);
  }
}

function addLeaves(cx, cy){
  const r = 2;
  for (let dy=-r; dy<=r; dy++){
    for (let dx=-r; dx<=r; dx++){
      if (dx*dx + dy*dy <= r*r){
        const x = cx+dx, y = cy+dy;
        if (x>=0 && x<simCols && y>=0 && y<simRows && grid[y][x]===EMPTY){
          grid[y][x] = LEAVES;
          isStatic[y][x] = true;
        }
      }
    }
  }
}

function updateDynamites(dt){
  for (let i=dynamites.length-1; i>=0; i--){
    const d = dynamites[i];
    d.timer -= dt;
    d.vy += 50 * dt;
    let newY = d.y + d.vy * dt;
    const bottom = Math.floor(newY + 2);
    const gx = Math.floor(d.x);
    if (bottom >= simRows || grid[bottom][gx] !== EMPTY){
      d.y = bottom - 2;
      d.vy = 0;
    } else {
      d.y = newY;
    }
    if (d.timer <= 0){
      explode(d);
      dynamites.splice(i,1);
    }
  }
}

function explode(d){
  const rDestroy = 8;
  const rPush = 12;
  for (let dy=-rPush; dy<=rPush; dy++){
    for (let dx=-rPush; dx<=rPush; dx++){
      const dist = Math.hypot(dx,dy);
      const x = d.x + dx;
      const y = d.y + dy;
      if (x<0 || x>=simCols || y<0 || y>=simRows) continue;
      if (dist <= rDestroy){
        grid[y][x] = EMPTY;
        isStatic[y][x] = false;
        delete soilExposeTime[`${x},${y}`];
      } else if (dist <= rPush){
        const dirX = dx === 0 ? 0 : dx > 0 ? 1 : -1;
        const dirY = dy === 0 ? 0 : dy > 0 ? 1 : -1;
        moveCell(x, y, dirX, dirY);
      }
    }
  }
}

function drawBackground(dt){
  const total = 240; // 4 minutes
  const phaseLen = total / 4;
  dayTime = (dayTime + dt) % total;
  const phase = Math.floor(dayTime / phaseLen);
  const phaseT = (dayTime % phaseLen) / phaseLen;
  const baseY = height * 0.7;
  let daylight = 0;
  currentSunX = width/2;

  if (phase === 0){ // morning - sun rises
    const sunRadius = 20;
    const sunY = height + sunRadius - phaseT*(height + sunRadius*2);
    if (sunY < baseY){
      daylight = Math.min((baseY - sunY)/(baseY - height*0.5), 1);
    }
    if (sunY + sunRadius > 0 && sunY - sunRadius < height){
      const grad = ctx.createRadialGradient(currentSunX, sunY, 0, currentSunX, sunY, sunRadius);
      grad.addColorStop(0, '#ff9aff');
      grad.addColorStop(1, '#ffde59');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(currentSunX, sunY, sunRadius, 0, Math.PI*2);
      ctx.fill();
    }
  } else if (phase === 1){ // afternoon - sun gone
    daylight = 1;
  } else if (phase === 2){ // evening - moon rises
    const moonRadius = 15;
    const moonY = height + moonRadius - phaseT*(height + moonRadius*2);
    daylight = 1;
    if (moonY < baseY){
      daylight = Math.max(0, 1 - (baseY - moonY)/(baseY - height*0.5));
    }
    if (moonY + moonRadius > 0 && moonY - moonRadius < height){
      const grad = ctx.createRadialGradient(currentSunX, moonY, 0, currentSunX, moonY, moonRadius);
      grad.addColorStop(0, '#00f0ff');
      grad.addColorStop(1, '#0088ff');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(currentSunX, moonY, moonRadius, 0, Math.PI*2);
      ctx.fill();
    }
  } else { // night
    daylight = 0.3;
  }

  currentDaylight = daylight;
  const nightLight = 1 - daylight;

  const dayTop = '#3a0ca3';
  const dayBottom = '#4361ee';
  const sunriseTop = '#ff006e';
  const sunriseBottom = '#ffbe0b';
  const nightTop = '#240046';
  const nightBottom = '#000000';
  let skyTop, skyBottom;

  if (phase === 0 && daylight < 1){
    skyTop = mixColor(nightTop, sunriseTop, daylight);
    skyBottom = mixColor(nightBottom, sunriseBottom, daylight);
  } else if (phase === 2 && daylight < 1){
    const d = 1 - daylight;
    skyTop = mixColor(dayTop, sunriseTop, d);
    skyBottom = mixColor(dayBottom, sunriseBottom, d);
  } else if (daylight >= 1){
    skyTop = dayTop;
    skyBottom = dayBottom;
  } else {
    skyTop = nightTop;
    skyBottom = nightBottom;
  }

  const grad = ctx.createLinearGradient(0,0,0,height);
  grad.addColorStop(0, skyTop);
  grad.addColorStop(1, skyBottom);
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,width,height);

  // stars
  ctx.fillStyle = '#fff';
  for (const s of stars){
    ctx.globalAlpha = nightLight * s.alpha;
    ctx.fillRect(s.x, s.y, s.size, s.size);
  }
  ctx.globalAlpha = 1;

  // clouds stay through day and night, tinted by daylight
  for (const c of clouds){
    c.x += c.speed * dt;
    if (c.x > width + 80) c.x = -80;
    for (const p of c.puffs){
      const cx = c.x + p.ox + p.w/2;
      const cy = c.y + p.oy + p.h/2;
      const light = 0.5 + daylight*0.5;
      ctx.fillStyle = mixColor('#555555', '#ffffff', light);
      ctx.beginPath();
      ctx.ellipse(cx, cy, p.w/2, p.h/2, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = mixColor('#333333', '#c0c0c0', light);
      ctx.beginPath();
      ctx.ellipse(cx, cy + p.h*0.25, p.w/2, p.h/4, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

function drawTerrain(){
  ctx.shadowBlur = 0;
  for (let y=0; y<simRows; y++){
    for (let x=0; x<simCols; x++){
      const val = grid[y][x];
      if (val === EMPTY) continue;
      const gx = x*cellSize, gy = y*cellSize;
      switch(val){
        case SOIL:
          ctx.fillStyle = '#b000d4';
          ctx.fillRect(gx, gy, cellSize, cellSize);
          ctx.fillStyle = '#7a0099';
          ctx.fillRect(gx, gy + cellSize*0.5, cellSize, cellSize*0.5);
          ctx.fillStyle = '#d14fff';
          ctx.fillRect(gx, gy, cellSize, cellSize*0.2);
          break;
        case GRASS:
          ctx.fillStyle = '#39ff14';
          ctx.fillRect(gx, gy, cellSize, cellSize);
          break;
        case WATER:
          ctx.fillStyle = '#00e5ff';
          ctx.fillRect(gx, gy, cellSize, cellSize);
          ctx.fillStyle = '#7df9ff';
          ctx.fillRect(gx, gy, cellSize, cellSize*0.3);
          ctx.fillStyle = '#0090ff';
          ctx.fillRect(gx, gy + cellSize*0.7, cellSize, cellSize*0.3);
          break;
        case TREE:
          ctx.fillStyle = '#ff8c00';
          ctx.fillRect(gx, gy, cellSize, cellSize);
          break;
        case LEAVES:
          ctx.fillStyle = '#32ff7e';
          ctx.fillRect(gx, gy, cellSize, cellSize);
          break;
      }
    }
  }
}

function drawDynamites(){
  for (const d of dynamites){
    const gx = d.x*cellSize;
    const gy = d.y*cellSize;
    ctx.shadowBlur = 8;
    ctx.fillStyle = '#ff073a';
    ctx.shadowColor = '#ff073a';
    ctx.fillRect(gx-cellSize/2, gy-cellSize*2, cellSize, cellSize*4);
    ctx.fillStyle = '#ffff00';
    ctx.shadowColor = '#ffff00';
    const fuse = Math.max(0, d.timer/5);
    ctx.fillRect(gx+cellSize/4, gy-cellSize*2-4, (cellSize/2)*fuse, 2);
    ctx.shadowBlur = 0;
  }
}

function draw(dt){
  drawBackground(dt);
  drawTerrain();
  drawDynamites();
}

let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  updateParticles();
  updateSoilAndGrass(dt);
  updateTrees(dt);
  updateDynamites(dt);
  draw(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// interaction
let pointerDown=false;
let pointerButton=0;
let pointerX=0, pointerY=0;
let dragX=0, dragY=0;

function updatePointer(e){
  const rect = canvas.getBoundingClientRect();
  pointerX = Math.floor((e.clientX - rect.left)/cellSize);
  pointerY = Math.floor((e.clientY - rect.top)/cellSize);
}

function plantTree(x,y){
  grid[y][x] = TREE;
  isStatic[y][x] = true;
  trees.push({x, baseY:y, age:0, height:1});
}

function placeDynamite(x,y){
  dynamites.push({x,y,vy:0,timer:5});
}

function modifyAtPointer(btn){
  const gridX = pointerX, gridY = pointerY;
  if (gridY<0 || gridY>=simRows || gridX<0 || gridX>=simCols) return;
  if (btn===0){
    if (currentMaterial === TREE){
      if (grid[gridY][gridX]===EMPTY && gridY+1<simRows && (grid[gridY+1][gridX]===SOIL || grid[gridY+1][gridX]===GRASS)){
        plantTree(gridX, gridY);
      }
    } else if (currentMaterial === DYNAMITE){
      placeDynamite(gridX, gridY);
    } else {
      const r=2;
      for (let dy=-r; dy<=r; dy++){
        for (let dx=-r; dx<=r; dx++){
          if (dx*dx+dy*dy <= r*r){
            const x = gridX+dx, y = gridY+dy;
            if (y>=0 && y<simRows && x>=0 && x<simCols && grid[y][x]===EMPTY){
              grid[y][x] = currentMaterial;
              isStatic[y][x] = false;
              if (currentMaterial===SOIL) soilExposeTime[`${x},${y}`] = 0;
            }
          }
        }
      }
    }
  } else if (btn===2){
    if (grid[gridY][gridX] !== EMPTY){
      grid[gridY][gridX] = EMPTY;
      isStatic[gridY][gridX] = false;
      delete soilExposeTime[`${gridX},${gridY}`];
    }
  }
}

function pushCell(x,y,dx,dy){
  if (x<0||x>=simCols||y<0||y>=simRows) return false;
  if (grid[y][x]===EMPTY) return true;
  const nx=x+dx, ny=y+dy;
  if (!pushCell(nx,ny,dx,dy)) return false;
  grid[ny][nx]=grid[y][x];
  isStatic[ny][nx]=false;
  if (grid[ny][nx]===SOIL){
    soilExposeTime[`${nx},${ny}`]=soilExposeTime[`${x},${y}`];
    delete soilExposeTime[`${x},${y}`];
  }
  grid[y][x]=EMPTY;
  isStatic[y][x]=false;
  return true;
}

function moveCell(x,y,dx,dy){
  const nx=x+dx, ny=y+dy;
  if (nx<0||nx>=simCols||ny<0||ny>=simRows) return;
  if (grid[y][x]===EMPTY) return;
  if (pushCell(nx,ny,dx,dy)){
    grid[ny][nx]=grid[y][x];
    isStatic[ny][nx]=false;
    if (grid[ny][nx]===SOIL) soilExposeTime[`${nx},${ny}`]=soilExposeTime[`${x},${y}`];
    grid[y][x]=EMPTY;
    isStatic[y][x]=false;
    delete soilExposeTime[`${x},${y}`];
  }
}

function moveRegion(cx,cy,dx,dy){
  const r=2;
  const cells=[];
  for (let dy0=-r; dy0<=r; dy0++){
    for (let dx0=-r; dx0<=r; dx0++){
      if (dx0*dx0+dy0*dy0 <= r*r){
        const x=cx+dx0, y=cy+dy0;
        if (x>=0 && x<simCols && y>=0 && y<simRows) cells.push({x,y});
      }
    }
  }
  cells.sort((a,b)=>{
    if (dy>0) return b.y - a.y;
    if (dy<0) return a.y - b.y;
    if (dx>0) return b.x - a.x;
    if (dx<0) return a.x - b.x;
    return 0;
  });
  for (const c of cells){
    moveCell(c.x, c.y, dx, dy);
  }
}

function dragMove(newX,newY){
  let dx = newX - dragX;
  let dy = newY - dragY;
  while (dx !== 0 || dy !== 0){
    const stepX = dx===0 ? 0 : dx>0 ? 1 : -1;
    const stepY = dy===0 ? 0 : dy>0 ? 1 : -1;
    moveRegion(dragX, dragY, stepX, stepY);
    dragX += stepX;
    dragY += stepY;
    dx -= stepX;
    dy -= stepY;
  }
}

let spawnInterval;
canvas.addEventListener('pointerdown', e => {
  pointerDown = true;
  pointerButton = e.button;
  updatePointer(e);
  if (mode==='place'){
    modifyAtPointer(pointerButton);
    clearInterval(spawnInterval);
    if (currentMaterial!==TREE && currentMaterial!==DYNAMITE)
      spawnInterval = setInterval(()=>modifyAtPointer(pointerButton), 50);
  } else if (mode==='interact') {
    dragX = pointerX;
    dragY = pointerY;
  }
});
canvas.addEventListener('pointermove', e => {
  updatePointer(e);
  if (pointerDown && mode==='interact'){
    dragMove(pointerX, pointerY);
  }
});
['pointerup','pointercancel','pointerout'].forEach(ev => canvas.addEventListener(ev, () => {
  pointerDown = false;
  clearInterval(spawnInterval);
}));
canvas.addEventListener('contextmenu', e => e.preventDefault());
</script>
</html>

